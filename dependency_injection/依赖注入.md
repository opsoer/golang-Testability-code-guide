## 依赖注入

依赖注入算是编写可测试性代码的最重要的原则了。什么是依赖注入，我的理解就是需要的对象或函数或者任何东西，我不在本地`new`，而是通过入参或者是全局变量来注入；对应到go里面，这类参数或者是全局变量我们一般需要定义为`interface`类型，这样可以极大的方便我们之后的单测编写。具体可以参考当前文件目录下面[bad.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/bad/bad_code.go)和[good.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/good/good_code.go)代码，并且有相关的测试代码[bad_test.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/bad/bad_code_test.go)和[good_test.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/good/good_code_test.go)。

首先看一下[bad.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/bad/bad_code.go)代码，`SomeFunc`是我们的业务函数，业务中我们需要更具id查询用户数据，因为要对查询操或者结果做一些处理，为了使得业务代码简单，所以我们封装了一个`selectValFromDBByID`函数去查询数据，并且返回结果。我看到过很多代码都是这么写的，很多人也觉得这样写很好呀，而且还专门封装了一个`selectValFromDBByID`基础函数，**简化了业务逻辑还提高了代码的重用性**，有什么问题吗？有啊，当然有，如果领导要你写单测，你咋写，自己在本地搭建一个数据库吗？如果代码的数据库的地址是不是本地呢，那你还要改代码依赖的数据库地址为本地地址，再去本地搭建一个数据库服务吗？这个函数还引入了其他的数据库服务或者缓存服务，那你不得搭建所有的依赖了等等很多问题。甚至我遇到几乎所有的代码都是这么组织的，一直也没出问题，`selectValFromDBByID`这种基础函数函数被调用的次数也特别多，代码复用率也特别高，但是**一旦要你补充单测**了，那你就得偿还你的**技术债务**了。

那好的代码怎么写呢，可以看一下[good.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/good/good_code.go)代码。刚刚开始学go的话，这段代码可能不是特别好理解，但是如果你熟知了go的`interface`和鸭子类型之后，这段代码其实就是go的编码风格。我们将`selectValFromDBByID`函数向上抽象了一个`DBOperate`的`interface`，并且定义一个DB的变量去实现`DBOperate`这个`interface`；仔细看不难发现，实现逻辑就是[bad.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/bad/bad_code.go)d的`selectValFromDBByID`实现逻辑；并且在业务逻辑`SomeFunc`的入参加入了一个`DBOperate`这个`interface`类型。代码逻辑差不多就这些。

接下来我们看一下单测的编写[good_test.go](https://github.com/opsoer/golang-testability-code-guide/blob/master/dependency_injection/good/good_code_test.go)，在单测中，我们只需去实现一个自己的`DBOperate`接口，然后测试调用`SomeFunc`的时候传进去就好了，这得益于go的鸭子类型，对于我们自己实现的`DBOperate`接口，我们收到什么参数返回什么结果，完全自己可控，而且测试代码可以直接运行，完全解耦了外部依赖，根本不需要什么去搭建数据库服务。而且单测的本质就是测试代码逻辑准确性，我们应该注重的是边界条件，不是搭建服务，如果你写单测很痛苦或者是不知道这么下手，也许你可以参考我的方法，对代码进行一点点的改造，也许单测也就很好写了，公司推行的单测覆盖率也能更好的去落地。

还有一种情况，也是我遇到的一种情况，大概就是，函数调用链非常深，十几层（个人感觉一般情况最多五层就可以了），也就是A调B，B调C，C调D，D调E，E调F.....，最后调到N，N调了一个类似于`selectValFromDBByID`的外部依赖函数，咋搞，不可能在A层开始传参一直传到N吧，我采取的方法是定义一个`interface`全局变量，然后在最开始的main函数或者init函数去初始化它，我建议是在init函数去初始化，否则有可能在你跑其他模块单测情况下，报`nil err`错，也就是这个全局的`interface`没有初始化。

